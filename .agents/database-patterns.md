# Database Patterns with Drizzle ORM

Comprehensive guidelines for database management using Drizzle ORM in the Public Talk Planner
project.

## Critical Database Management Rules

### NEVER Execute SQL Files Manually

**Rule:** ALL database changes MUST be applied through schema modifications in
`server/database/schema.ts`

**Why This Rule Exists:**

- SINGLE SOURCE OF TRUTH: Schema files are the authoritative definition of database structure
- SCHEMA DRIFT PREVENTION: Manual SQL execution creates inconsistency between code and database
- VERSION CONTROL: Schema changes are tracked in git, manual SQL changes are not
- TYPE SAFETY: TypeScript types are inferred from schema, manual changes break type inference
- TEAM COLLABORATION: Other developers won't see manual changes reflected in codebase

**Consequences of Breaking This Rule:**

- Database structure differs from schema definition
- TypeScript types become incorrect or outdated
- Migration history becomes incomplete
- Rollback and deployment automation fails
- Other team members encounter runtime errors
- Production deployments fail due to schema mismatches

**Correct Workflow:**

```typescript
// ✅ Correct: Modify schema in server/database/schema.ts
export const speakers = sqliteTable("speakers", {
  id: text("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  // Add new field here
  email: text("email"),
  createdAt: integer("created_at", { mode: "timestamp" }).notNull(),
})

// Then prompt user to run: pnpm db:generate
```

```sql
-- ❌ Wrong: Never execute SQL files directly
-- ALTER TABLE speakers ADD COLUMN email TEXT;
-- This creates schema drift and breaks type safety!
```

### ALWAYS Ask User to Generate Migrations

**Rule:** NEVER run `pnpm db:generate` yourself; ALWAYS prompt the user to execute this command
after schema changes

**Why This Rule Exists:**

- DELIBERATE ACTION: Migration generation should be conscious, reviewed decision
- EXPERIMENTATION SAFETY: Prevents unwanted migrations during schema exploration
- USER AWARENESS: User knows when database changes are being committed
- REVIEW OPPORTUNITY: User can review schema changes before migration generation
- DEPLOYMENT CONTROL: User decides when changes are ready for migration

**Consequences of Automatic Generation:**

- Experimental schema changes create unwanted migrations
- User unaware of database structure changes
- Migration files clutter git history unnecessarily
- Difficult to distinguish intentional from accidental migrations
- Testing and development workflows disrupted

**Correct Workflow Pattern:**

```typescript
// After modifying schema...

// ✅ Correct: Prompt user with clear instruction
console.log("Database schema has been updated.")
console.log("Please run: pnpm db:generate")
console.log("This will create migration files for your schema changes.")

// Wait for user to execute command
// User reviews changes and decides when ready
```

**Anti-Pattern Note:** Never programmatically execute the migration generation command. Always
prompt the user to run it manually.

**User Prompt Template:**

```
Database schema has been updated in `server/database/schema.ts`.

Please run the following command to generate migration files:
  pnpm db:generate

After generation, review the migration files in `server/database/migrations/`
before committing.
```

### NEVER Edit Migration Files Manually

**Rule:** Migration files are generated by Drizzle and should remain unchanged

**Why This Rule Exists:**

- AUTOMATED GENERATION: Drizzle generates correct SQL based on schema differences
- CONSISTENCY: Manual edits can create mismatches with schema definitions
- REVERSIBILITY: Drizzle manages rollback based on generated migration structure
- AUDIT TRAIL: Generated migrations provide accurate history of schema evolution
- CONFLICT RESOLUTION: Manual edits complicate merge conflicts and migration ordering

**Exceptions (Rare Cases):**

- Data migration logic (migrations that transform existing data)
- Custom SQL features not supported by Drizzle schema syntax
- Database-specific optimizations (indexes, constraints)

**When Manual Edits Are Needed:**

1. Generate migration with `pnpm db:generate`
2. Review generated SQL in migration file
3. Add custom SQL logic AFTER auto-generated statements
4. Document why manual edit was necessary
5. Test migration thoroughly in development environment
6. Include clear comments explaining manual changes

**Example of Acceptable Manual Addition:**

```sql
-- Generated by Drizzle (DO NOT EDIT THIS PART)
CREATE TABLE speakers (
  id TEXT PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL
);

-- Manual addition: Data migration (DOCUMENT WHY)
-- Migrating existing speaker data from old format
UPDATE speakers SET first_name = UPPER(first_name) WHERE legacy_format = 1;
```

## Schema Design Patterns

### Table Definition Standards

- DEFINE all tables in `server/database/schema.ts`
- USE descriptive table and column names that reflect domain concepts
- INCLUDE `createdAt` and `updatedAt` timestamps on all tables
- USE `mode: "timestamp"` for datetime fields (automatic conversion)
- USE `mode: "boolean"` for boolean fields (SQLite compatibility)
- STORE custom date fields as unix timestamps (integer, seconds) for consistency
- EXPORT inferred TypeScript types: `export type TableName = typeof tableName.$inferSelect`

**Example Schema Definition:**

```typescript
import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core"

export const speakers = sqliteTable("speakers", {
  id: text("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email"),
  phone: text("phone"),
  congregation: text("congregation"),
  isArchived: integer("is_archived", { mode: "boolean" }).notNull().default(false),
  // Unix timestamp for custom date (seconds since epoch)
  availableFrom: integer("available_from", { mode: "number" }),
  createdAt: integer("created_at", { mode: "timestamp" }).notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp" }).notNull(),
})

// Export type for use in application code
export type Speaker = typeof speakers.$inferSelect
export type NewSpeaker = typeof speakers.$inferInsert
```

### Database Access Patterns

- CREATE `useDrizzle()` composable in `server/utils/drizzle.ts`
- EXPORT commonly used operators: `eq`, `and`, `or`, `sql`, `gte`, `lte`
- USE transactions for operations affecting multiple tables
- VALIDATE input data before database operations
- HANDLE errors gracefully with proper error messages

**Example Database Utility:**

```typescript
// server/utils/drizzle.ts
import { drizzle } from "drizzle-orm/d1"
export { sql, eq, and, or, gte, lte, desc, asc } from "drizzle-orm"
import * as schema from "~/server/database/schema"

export function useDrizzle() {
  return drizzle(hubDatabase(), { schema })
}

export const tables = schema
```

### Transaction Patterns

- USE transactions when updating multiple related records
- ROLLBACK transactions on any error to maintain consistency
- KEEP transactions short and focused
- AVOID long-running operations within transactions

**Example Transaction Usage:**

```typescript
const db = useDrizzle()

await db.transaction(async tx => {
  // Insert talk
  const [talk] = await tx
    .insert(tables.talks)
    .values({
      id: crypto.randomUUID(),
      title: "New Talk",
      speakerId: speaker.id,
      createdAt: new Date(),
      updatedAt: new Date(),
    })
    .returning()

  // Create schedule entry
  await tx.insert(tables.schedules).values({
    id: crypto.randomUUID(),
    talkId: talk.id,
    scheduledDate: dateTimestamp,
    createdAt: new Date(),
    updatedAt: new Date(),
  })

  // If any operation fails, both are rolled back
})
```

## Migration Workflow Best Practices

### Complete Migration Workflow

1. **Modify Schema**
   - Edit `server/database/schema.ts`
   - Add, remove, or modify table definitions
   - Update TypeScript types as needed

2. **Prompt User for Migration**

   ```
   Database schema has been updated.
   Please run: pnpm db:generate
   ```

3. **User Generates Migration**
   - User executes `pnpm db:generate`
   - Drizzle analyzes schema differences
   - Generates SQL migration files in `server/database/migrations/`
   - Creates snapshot in `server/database/migrations/meta/`

4. **Review Migration**
   - Open generated `.sql` file in `server/database/migrations/`
   - Verify SQL statements match intended changes
   - Check for unintended table drops or data loss
   - Validate foreign key relationships

5. **Test Migration**
   - Test migration in local development environment
   - Verify data integrity after migration
   - Test application functionality with new schema
   - Confirm TypeScript types work correctly

6. **Commit Changes**
   - Commit schema changes in `server/database/schema.ts`
   - Commit generated migration files together
   - Commit updated meta/snapshot files
   - Include descriptive commit message explaining schema changes

### Migration Naming Convention

Drizzle generates migration files with timestamp prefixes:

```
server/database/migrations/
├── 0000_initial_setup.sql
├── 0001_add_speakers_table.sql
├── 0002_add_talks_table.sql
├── meta/
│   ├── 0000_snapshot.json
│   ├── 0001_snapshot.json
│   ├── 0002_snapshot.json
│   └── _journal.json
```

- Migrations execute in numerical order
- Each migration builds on previous state
- Never reorder or rename migration files
- Never delete old migration files

### Handling Migration Conflicts

When multiple developers work on schema simultaneously:

1. **Pull Latest Changes**
   - Always pull latest migrations before creating new ones
   - Resolve git conflicts in schema files first

2. **Regenerate if Needed**
   - If migration order conflicts, regenerate migrations
   - Test merged schema thoroughly

3. **Communicate Schema Changes**
   - Notify team of significant schema changes
   - Document breaking changes in commit messages
   - Update API documentation if schema affects endpoints

## Database Security Patterns

### Input Validation

- VALIDATE all user inputs before database operations
- USE Zod schemas for request body validation
- SANITIZE input to prevent SQL injection
- VALIDATE foreign key references exist before insertion

**Example with Validation:**

```typescript
import { createSpeakerSchema } from "~/shared/utils/schemas"

export default defineEventHandler(async event => {
  // Validate input with Zod schema
  const body = await validateBody(event, createSpeakerSchema)

  const db = useDrizzle()

  // Input is now type-safe and validated
  const [speaker] = await db
    .insert(tables.speakers)
    .values({
      id: crypto.randomUUID(),
      firstName: body.firstName,
      lastName: body.lastName,
      email: body.email,
      phone: body.phone,
      congregation: body.congregation,
      isArchived: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    })
    .returning()

  return speaker
})
```

### SQL Injection Prevention

Drizzle ORM uses parameterized queries automatically, but always:

- NEVER concatenate user input into SQL strings
- USE Drizzle's query builder for all database operations
- VALIDATE and sanitize input at API boundaries
- AVOID raw SQL queries when possible

**Safe Query Patterns:**

```typescript
// ✅ Safe: Parameterized query via Drizzle
const speaker = await db.select().from(tables.speakers).where(eq(tables.speakers.id, userId))

// ❌ Unsafe: String concatenation with user input (DON'T DO THIS)
```

## Performance Optimization

### Query Optimization

- SELECT only needed columns, not all columns
- USE indexes for frequently queried columns
- LIMIT result sets when appropriate
- BATCH insert operations when inserting multiple records

**Example Optimized Query:**

```typescript
// ✅ Optimized: Select specific columns
const speakers = await db
  .select({
    id: tables.speakers.id,
    firstName: tables.speakers.firstName,
    lastName: tables.speakers.lastName,
  })
  .from(tables.speakers)
  .where(eq(tables.speakers.isArchived, false))
  .limit(50)
```

### Batch Operations

- INSERT multiple records in single query
- UPDATE multiple records with single WHERE clause
- AVOID N+1 query problems with joins

**Example Batch Insert:**

```typescript
// ✅ Efficient: Single batch insert
const newSpeakers = [
  { firstName: "John", lastName: "Doe", email: "john@example.com" },
  { firstName: "Jane", lastName: "Smith", email: "jane@example.com" },
]

await db.insert(tables.speakers).values(
  newSpeakers.map(speaker => ({
    id: crypto.randomUUID(),
    ...speaker,
    isArchived: false,
    createdAt: new Date(),
    updatedAt: new Date(),
  }))
)
```

## Anti-Patterns to Avoid

### Common Mistakes

**❌ Executing SQL Files Directly**

Never execute SQL files manually using database CLI tools or scripts. Always modify the schema and
generate migrations through Drizzle.

**❌ Generating Migrations Without User Confirmation**

Never programmatically run migration generation. Always prompt the user to execute the command
manually.

**❌ Editing Generated Migration Files**

Don't modify auto-generated SQL unless absolutely necessary for data migrations or custom logic.

**❌ Skipping Migration Generation**

Don't modify schema without generating migrations. This creates schema drift between code and
database.

**❌ Using Raw SQL with User Input**

Never concatenate user input into SQL queries. Always use Drizzle's parameterized queries.

**❌ Not Using Transactions for Related Operations**

Without transactions, partial updates can occur if errors happen during multi-step operations.

## Reference Files

- Schema definition: `server/database/schema.ts`
- Migration files: `server/database/migrations/`
- Database utilities: `server/utils/drizzle.ts`
- Validation schemas: `shared/utils/schemas/`
- Date/time utilities: `app/utils/date.ts`
